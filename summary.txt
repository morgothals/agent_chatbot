demo.py tartalma:
# demo.py
from tools import get_order_info, load_memory, save_memory, call_gemini_api
from planner import parse_user_input, plan
from validator import parse_and_validate

def main():
    print("=== Order lookup ===")
    print(get_order_info({"order_id": "A1003"}))  
    print(get_order_info({"order_id": "XXXX"}))   # hibakezelés

    print("\n=== Memory load/save ===")
    mem = load_memory()
    print("Before:", mem)
    mem["history"].append({"user":"Teszt","bot":"Válasz"})
    save_memory(mem)
    print("After:", load_memory())

    print("\n=== Intent/entity parsing ===")
    utterance = "Hol tart az A1003-as rendelésem?"
    parsed = parse_user_input(utterance)
    print("parse_user_input:", parsed)

    print("\n=== Validation ===")
    try:
        ok = parse_and_validate(utterance)
        print("parse_and_validate:", ok)
    except Exception as e:
        print("Validation error:", e)

    # GEMINI API hívás (ha éles kulccsal futtatod)
    print("\n=== call_gemini_api demo ===")
    resp = call_gemini_api(
        model="gemini-2.0-flash",
        contents="Generate JSON with intent and entities for: Hol tart az A1003-as rendelésem?"
    )
    print("RAW GEMINI:", resp)

if __name__ == "__main__":
    main()


executor.py tartalma:
import json
from planner import plan
from tools import get_order_info
from memory import log_interaction


def invoke_order_status(order_id: str) -> dict:
    """
    Csak a get_order_info() eredményét adja vissza JSON-ként,
    hibával vagy sikeres adatcsomaggal.
    """
    return get_order_info({"order_id": order_id})


def handle_user_request(text: str) -> dict:
    """
    2.6 + 2.7: 
      - parse → intent+entities 
      - missing / multi-entity / invalid-id edge-case-ek
      - tool invoke 
      - memory log 
      - reply
    """
    # 1) Planner
    res = plan(text)
    intent   = res.get("intent")
    entities = res.get("entities", {})

    # 2a) Validációs és missing-entity hibák
    if "error" in res:
        reply = res["error"]
        log_interaction(text, intent, entities, reply)
        return {"agent_reply": reply}

    # 2b) Több entity esetén kérdés
    oid = entities.get("order_id")
    if isinstance(oid, list) and len(oid) > 1:
        # pl. ["A1003", "A1004"]
        opts = " vagy ".join(oid)
        reply = f"Melyik rendelésre gondolsz: {opts}?"
        log_interaction(text, intent, entities, reply)
        return {"agent_reply": reply}

    # 3) Tool invocation
    if intent in ("order_status", "shipping_time"):
        result = get_order_info({"order_id": oid})
    else:
        result = {"error": f"Nem kezelt intent: {intent}"}

    # 4) Válasz formázása + special-case hibák
    if "error" in result:
        err = result["error"]
        if err.startswith("Nincs ilyen rendelés"):
            reply = "Nincs ilyen rendelés"
        else:
            reply = err
    else:
        if intent == "order_status":
            reply = f"Az {result['order_id']} rendelés státusza: {result['status']}."
        elif intent == "shipping_time":
            reply = (f"Az {result['order_id']} csomag feladásának dátuma: "
                     f"{result['shipping_date']}, várható érkezés: {result['delivery_estimate']}.")
        else:
            reply = json.dumps(result, ensure_ascii=False)

    # 5) Memória naplózása
    log_interaction(text, intent, entities, reply)

    return {
        "intent": intent,
        "entities": entities,
        "result": result,
        "agent_reply": reply
    }

if __name__ == "__main__":
    for utt in [
        "Hol tart az A1003-as rendelésem?",
        "Hol tart a A1003 as rendelésem?",
        "Hiányzó id teszt",
        "Többszörös id teszt"
    ]:
        # demo: multi-entity szimulációhoz manuálisan
        if "Többszörös" in utt:
            demo_entities = {"order_id": ["A1003", "A1004"]}
            demo_res = {"intent": "order_status", "entities": demo_entities}
            # kicseréljük a plan-t
            from planner import parse_user_input
            def fake_plan(_): return demo_res
            import planner; planner.plan = fake_plan
            out = handle_user_request(utt)
        else:
            out = handle_user_request(utt)
        print(f">>> {utt}\n→ {out['agent_reply']}\n")


main.py tartalma:
# main.py

from executor import handle_user_request
from tools import load_memory

def main():
    print("=== Ügynök Chatbot CLI ===")
    load_memory()  
    print("=== Ügynök elindult, memória betöltve ===")
    print("Írj be egy kérdést (kilépés: 'exit')\n")
    while True:
        text = input(">> ").strip()
        if text.lower() in ("exit", "quit"):
            print("Viszlát!")
            break
        response = handle_user_request(text)
        print(response["agent_reply"], "\n")

if __name__ == "__main__":
    main()


memory.json tartalma:
{
  "history": [
    {
      "user": "Teszt",
      "bot": "Válasz"
    },
    {
      "user": "Teszt",
      "bot": "Válasz"
    },
    {
      "user": "Teszt",
      "bot": "Válasz"
    },
    {
      "user": "Teszt",
      "bot": "Válasz"
    },
    "x",
    {
      "timestamp": "2025-05-19T19:20:59.659292",
      "user": "Hol tart a A1003 as rendelésem?",
      "intent": "order_status",
      "entities": {
        "order_id": "A1003"
      },
      "result": {
        "order_id": "A1003",
        "status": "Teljesítve",
        "shipping_date": "2025-05-01",
        "delivery_estimate": "2025-05-07"
      }
    },
    {
      "timestamp": "2025-05-19T19:27:07.888927",
      "user": "Hol tart a A1006 os rendelésem?",
      "intent": "order_status",
      "entities": {
        "order_id": "A1006"
      },
      "agent": "Az A1006 rendelés státusza: Visszaküldve."
    },
    {
      "timestamp": "2025-05-19T19:27:47.768728",
      "user": "Mikor szállították ki?",
      "intent": null,
      "entities": {},
      "agent": "Kérlek, add meg a következő adatot a folytatáshoz: order_id."
    },
    {
      "timestamp": "2025-05-19T19:27:58.023064",
      "user": "A1006",
      "intent": "order_status",
      "entities": {
        "order_id": "A1006"
      },
      "agent": "Az A1006 rendelés státusza: Visszaküldve."
    },
    {
      "timestamp": "2025-05-19T19:34:11.079045",
      "user": "Hol tart a A1006 os rendelésem?",
      "intent": "order_status",
      "entities": {
        "order_id": "A1006"
      },
      "agent": "Az A1006 rendelés státusza: Visszaküldve."
    },
    {
      "timestamp": "2025-05-19T19:37:16.682590",
      "user": "Hol tart a A1003 as rendelésem?",
      "intent": "order_status",
      "entities": {
        "order_id": "A1003"
      },
      "agent": "Az A1003 rendelés státusza: Teljesítve."
    },
    {
      "timestamp": "2025-05-19T19:49:02.538475",
      "user": "Hol tart a A1003 as rendelésem?",
      "intent": "order_status",
      "entities": {
        "order_id": "A1003"
      },
      "agent": "Az A1003 rendelés státusza: Teljesítve."
    }
  ]
}

memory.py tartalma:
import json
from datetime import datetime
from tools import load_memory, save_memory

def log_interaction(user: str, intent: str, entities: dict, agent: str) -> None:
    """
    Naplózza a beszélgetési lépést a memory.json-ben.
    A bejegyzés tartalmazza:
      - timestamp: ISO formátumú UTC időpont
      - user: a felhasználó kérdése
      - intent: a felismerés szerinti intent név (vagy None)
      - entities: a kivont entitások dict
      - agent: a chatbot emberi nyelvű válasza vagy hibaüzenete
    """
    mem = load_memory()
    # Bizonyosodjunk meg róla, hogy van history kulcs
    if "history" not in mem or not isinstance(mem["history"], list):
        mem["history"] = []
    # Új bejegyzés hozzáadása
    mem["history"].append({
        "timestamp": datetime.utcnow().isoformat(),
        "user": user,
        "intent": intent,
        "entities": entities,
        "agent": agent
    })
    save_memory(mem)


orders.json tartalma:
{
    "orders": [
        {
            "order_id": "A1001",
            "status": "Feldolgozás alatt",
            "shipping_date": "2025-05-12",
            "delivery_estimate": "2025-05-18"
        },
        {
            "order_id": "A1002",
            "status": "Szállítás alatt",
            "shipping_date": "2025-05-08",
            "delivery_estimate": "2025-05-14"
        },
        {
            "order_id": "A1003",
            "status": "Teljesítve",
            "shipping_date": "2025-05-01",
            "delivery_estimate": "2025-05-07"
        },
        {
            "order_id": "A1004",
            "status": "Feldolgozás alatt",
            "shipping_date": "2025-05-10",
            "delivery_estimate": "2025-05-15"
        },
        {
            "order_id": "A1005",
            "status": "Szállítás alatt",
            "shipping_date": "2025-05-06",
            "delivery_estimate": "2025-05-11"
        },
        {
            "order_id": "A1006",
            "status": "Visszaküldve",
            "shipping_date": "2025-04-28",
            "delivery_estimate": "2025-05-03"
        },
        {
            "order_id": "A1007",
            "status": "Teljesítve",
            "shipping_date": "2025-04-30",
            "delivery_estimate": "2025-05-05"
        },
        {
            "order_id": "A1008",
            "status": "Feldolgozás alatt",
            "shipping_date": "2025-05-11",
            "delivery_estimate": "2025-05-17"
        },
        {
            "order_id": "A1009",
            "status": "Szállítás alatt",
            "shipping_date": "2025-05-07",
            "delivery_estimate": "2025-05-13"
        },
        {
            "order_id": "A1010",
            "status": "Sikertelen kézbesítés",
            "shipping_date": "2025-05-04",
            "delivery_estimate": "2025-05-10"
        },
        {
            "order_id": "A1011",
            "status": "Teljesítve",
            "shipping_date": "2025-04-25",
            "delivery_estimate": "2025-05-01"
        },
        {
            "order_id": "A1012",
            "status": "Feldolgozás alatt",
            "shipping_date": "2025-05-10",
            "delivery_estimate": "2025-05-16"
        },
        {
            "order_id": "A1013",
            "status": "Szállítás alatt",
            "shipping_date": "2025-05-09",
            "delivery_estimate": "2025-05-15"
        },
        {
            "order_id": "A1014",
            "status": "Teljesítve",
            "shipping_date": "2025-04-27",
            "delivery_estimate": "2025-05-02"
        },
        {
            "order_id": "A1015",
            "status": "Feldolgozás alatt",
            "shipping_date": "2025-05-10",
            "delivery_estimate": "2025-05-14"
        }
    ]
}

planner.py tartalma:
import json
import re
from pathlib import Path
from tools import call_gemini_api
from validator import validate_intent, validate_entities, ValidationError

# ——————————————————————————————————————————————
# Konfiguráció betöltése
# ——————————————————————————————————————————————
CONFIG_DIR = Path(__file__).parent / "config"
INTENTS = json.loads((CONFIG_DIR / "intents.json").read_text(encoding="utf-8"))
ENTITIES = json.loads((CONFIG_DIR / "entities.json").read_text(encoding="utf-8"))
VALID_INTENTS = ", ".join(INTENTS.keys())

def parse_user_input(text: str) -> dict:
    """
    Meghívja a Gemini-2.0-flash modellt, hogy felismerje az intent-et és az entitásokat.
    Csak tiszta JSON-t várunk vissza.
    """
    # Normalizáció
    text = text.strip()
    text = re.sub(r"\b([Aa][0-9]{4}) as\b", r"\1-as", text)
    text = re.sub(r"\ba\s+([AEIOUÁÉÍÓÖŐÚÜŰaeiouáéíóöőúüű])", r"az \1", text)

    prompt = f"""System:
Az alábbi intent-ek közül válassz: {VALID_INTENTS}.
Elemezd a következő felhasználói mondatot, és add vissza kizárólag JSON formátumban:
  {{
    "intent": "...",
    "entities": {{ ... }}
  }}
Ne írj semmi mást, csak a tiszta JSON-t.

User:
"{text}"
"""

    raw = call_gemini_api(model="gemini-2.0-flash", contents=prompt)
    clean = re.sub(r"^```json\s*|\s*```$", "", raw.strip())

    try:
        data = json.loads(clean)
        return {
            "intent": data.get("intent"),
            "entities": data.get("entities", {})
        }
    except json.JSONDecodeError:
        return {"intent": None, "entities": {}}


def plan(text: str) -> dict:
    """
    Planner főfüggvénye:
      1) parse_user_input → intent+entities
      2) hibakezelés:
         - nincs intent → error
         - több order_id → clarify
         - hiányzó kötelező entity → error
         - validációs hiba → error
      3) siker → { intent, entities }
    """
    parsed = parse_user_input(text)
    intent = parsed.get("intent")
    entities = parsed.get("entities", {})

    # nincs intent
    if not intent:
        return {"error": "Sajnálom, nem értettem a kérdés típusát. Kérlek, fogalmazd át!"}

    # többféle order_id esetén tisztázó kérdés
    if intent in ("order_status", "shipping_time"):
        oid = entities.get("order_id")
        if isinstance(oid, list) and len(oid) > 1:
            opts = " vagy ".join(oid)
            return {"clarify": f"Melyik rendelésre gondolsz: {opts}?"}

    # hiányzó kötelező entitások
    required = INTENTS.get(intent, {}).get("required_entities", [])
    missing = [e for e in required if e not in entities or not entities[e]]
    if missing:
        names = ", ".join(missing)
        return {"error": f"Kérem, add meg a következő adatot a folytatáshoz: {names}."}

    # validáció
    try:
        validate_intent(intent)
        validate_entities(intent, entities)
    except ValidationError as e:
        return {"error": str(e)}

    # minden rendben
    return {"intent": intent, "entities": entities}


if __name__ == "__main__":
    # Gyors manuális teszt
    samples = [
        "Hol tart az A1003-as rendelésem?",
        "Mikorra várható az A1005 szállítása?",
        "Foo Bar",
        # Több entity demo (itt a plan-t monkeypatch-eld a teszt során)
    ]
    for utt in samples:
        print(f">>> {utt}\n    → {plan(utt)}\n")


pytest.ini tartalma:
[pytest]
testpaths = tests
pythonpath = .

RENDSZERTERV.md tartalma:

## Feladatleírás

Célod egy olyan **ügyfélszolgálati chatbot** (automatikus válaszadó ügynök) elkészítése, amely a vásárlók rendelésekkel kapcsolatos kérdéseire képes automatikusan választ adni (például rendelés állapota, szállítási időpontok).

A chatbot működéséhez egy mesterséges intelligencia modellt (**gemini-2.0-flash** API-val) fogsz használni. A chatbot:

* Automatikusan értelmezi a felhasználói kérdést,
* Alfeladatokra bontja (például rendelés azonosító kinyerése),
* Lekéri az információt az előre létrehozott dummy adatokat tartalmazó JSON fájlból,
* Perzisztens állapotot tárol (`memory.json`),
* Iteratívan javítja saját tervét, ha valamilyen hiba történik.

---

## Fő komponensek (röviden összefoglalva)

1. **Planner (Tervező)**:

   * A felhasználó kérésének értelmezése és alfeladatokra bontása.

2. **Executor (Végrehajtó)**:

   * JSON fájlok betöltése, keresés, válasz generálása.

3. **Memory (Memória)**:

   * A chatbot korábbi lépéseinek és eredményeinek tárolása JSON-ben.

4. **Feedback loop (Visszacsatolási hurok)**:

   * A végrehajtás eredményeinek ellenőrzése, hibák felismerése, és szükség esetén a terv finomítása.

---

## Feladat lépésekre bontva

### ✅ **1. lépés: Projekt beállítása**

* Hozz létre egy projektmappát (pl. `agent_chatbot`).
* Tedd bele a már elkészített fájlokat (`memory.json`, `orders.json`, `tools.py`).
* Készíts egy külön Python fájlt, például `main.py`.

### ✅ **2. lépés: Ügynök felépítésének megtervezése (Agent Planning)**

* Döntsd el, hogyan fogja felismerni a chatbot a felhasználói szándékot:

  * Példa: "Hol tart az A1003-as rendelésem?" → Rendelés állapot lekérdezése, azonosító: A1003.
* Tervezd meg az alfeladatokat:

  * Szándék felismerése
  * Azonosító (pl. A1003) kinyerése
  * JSON-ből lekérdezés
  * Válasz megformázása
* Tervezd meg a memóriakezelést:

  * Előző válaszok és kérdések naplózása.



## 2. lépés részletes bontás: Ügynök felépítésének megtervezése

### 2.1. Szándék- és entitásdefiníció kidolgozása

1. **Lehetséges szándékok (intent-ek) listázása**

   * `order_status` – Rendelés állapot lekérdezése
   * `shipping_time` – Szállítási idő lekérdezése
   * `cancel_order` – Rendelés törlése (későbbi bővítés)
   * stb.

Részletesen kidolgozott a 2.1-es pontot: a chatbot által támogatott **szándékokat** (intent-eket) és az ezekhez tartozó **entitásokat**.

---

## 2.1 Szándék- és entitásdefiníció

### 1. Szándékok (Intent-ek)

| **Intent név**   | **Leírás**                                              | **Kötelező entitások**    | **Példa felhasználói mondatok**                                     |
| ---------------- | ------------------------------------------------------- | ------------------------- | ------------------------------------------------------------------- |
| `order_status`   | Rendelés állapotának lekérdezése                        | `order_id`                | „Hol tart az A1003-am?”<br>„Mi a státusza az A1005 rendelésnek?”    |
| `shipping_time`  | Szállítás várható idejének lekérdezése                  | `order_id`                | „Mikor érkezik az A1002?”<br>„Mikor kapom meg a A1008-as csomagot?” |
| `cancel_order`   | Rendelés törlése, módosítása (később bővíthető)         | `order_id`                | „Törölném az A1004-es rendelést.”                                   |
| `order_history`  | Felhasználó összes rendelésének listázása               | –                         | „Mutasd a rendeléseim listáját.”<br>„Mik a korábbi rendeléseim?”    |
| `refund_request` | Visszatérítés igénylése                                 | `order_id`, `reason`      | „Szeretnék visszatérítést kérni az A1006-ra, mert sérült.”          |
| `update_address` | Szállítási cím módosítása                               | `order_id`, `new_address` | „Cseréld le az A1007-es rendelés címét erre: …”                     |
| `product_info`   | Termékinformáció lekérdezése                            | `product_id`              | „Mondj többet a P200 termékről.”                                    |
| `greeting`       | Köszönés, általános bevezetés                           | –                         | „Szia!”<br>„Helló, hol tudok rendelni?”                             |
| `goodbye`        | Búcsú, beszélgetés lezárása                             | –                         | „Köszönöm, viszlát!”                                                |
| `help`           | Segítségkérés, rendelkezésre álló parancsok ismertetése | –                         | „Miben segítesz?”<br>„Mit tudsz?”                                   |

---

### 2. Entitások (Entity-k)

| **Entitás neve** | **Típus**       | **Leírás**                             | **Mintaértékek / minták**         |
| ---------------- | --------------- | -------------------------------------- | --------------------------------- |
| `order_id`       | String          | Rendelés azonosító                     | `A1001`, `B2345`                  |
| `product_id`     | String          | Termékazonosító                        | `P200`, `X123`                    |
| `new_address`    | String (szöveg) | Új szállítási cím                      | `Budapest, Fő u. 10.`             |
| `reason`         | String (szöveg) | Visszatérítés oka                      | `Sérült`, `Rosszul működik`       |
| `date`           | Date            | Dátum (kérés vagy eseményre vonatkozó) | `2025-05-20`, `május 20, 2025`    |
| `payment_method` | Enum            | Fizetési mód                           | `bankkártya`, `utánvét`, `PayPal` |
| `quantity`       | Integer         | Mennyiség                              | `1`, `2`, `10`                    |
| `greeting_type`  | Enum            | Köszönés típusa                        | `hello`, `hi`, `szia`             |
| `language`       | Enum            | Kommunikáció nyelve                    | `hu`, `en`                        |

---

### 3. JSON kimenet szerkezete

A Planner ez alapján a JSON szerkezet alapján adja vissza a vizsgált szándékot és entitásokat:

```json
{
  "intent": "order_status",
  "entities": {
    "order_id": "A1003"
  }
}
```

Minden intentnél csak a szükséges entitás(ok) jelenik meg, a többi kulcs opcionálisan maradhat üres objektum.

---

### 4. Minta-Prompt a Gemini API-hez

```text
System: „Elemezd a következő felhasználói mondatot, és add vissza JSON formátumban: intent és entities.”
User: „Hol tart az A1003-as rendelésem?”
---
Várt válasz:
{
  "intent": "order_status",
  "entities": {
    "order_id": "A1003"
  }
}
```

---

### 5. Kiinduló kódrészlet a `parse_user_input()` függvényhez

```python
import json

def parse_user_input(text: str) -> dict:
    prompt = f"""
    Elemezd a következő mondatot, és add vissza JSON-ben:
    Mondat: "{text}"
    Válasz formátum: {{ "intent": "...", "entities": {{ ... }} }}
    """
    response = call_gemini_api(model="gemini-2.0-flash", prompt=prompt)
    try:
        data = json.loads(response)
        return {
            "intent": data.get("intent"),
            "entities": data.get("entities", {})
        }
    except json.JSONDecodeError:
        # Ha nem valid JSON, hibajelzés
        return {"intent": None, "entities": {}}
```

---




2. **Entitások (entity-k) definiálása**

   * `order_id` – rendelés azonosító (pl. A1003)
   * `date` – dátumkérés
   * később: `product_name`, `customer_name` stb.

### 2.2. Minta-példák gyűjtése és prompt-tervezés

1. **Tipikus felhasználói kérdések gyűjtése**

   * Hol tart az A1003-as rendelésem?
   * Mikorra várható az A1005 szállítása?
   * Mik a rendeléseim állapotai?
2. **Prompt-sablonok készítése a Gemini modellhez**

   * „Intent felismerés: …” + „Válaszd ki a user szándékát és az entitásokat JSON formában.”
   * Teszteld vissza: Prompt → várt JSON output (pl. `{ "intent":"order_status", "order_id":"A1003" }`)

   ## 2.2. Minta-példák gyűjtése és prompt-tervezés

### Tipikus felhasználói kérdések

- **order_status**
  * Hol tart az A1003-as rendelésem?
  * Mi a státusza az A1005-nek?
  * Megnéznéd, hogy feldolgozás alatt van-e az A1002-es rendelésem?
* **shipping_time**
  * Mikorra várható az A1005 szállítása?
  * Mikor érkezik meg az A1004-es csomag?
* **order_history**
  * Mik a rendeléseim állapotai?
  * Kérlek, mutasd a korábbi rendelések listáját!
* **cancel_order**
  * Szeretném törölni az A1006-os rendelést.
  * Hogyan mondhatom le az A1010-et?
* **product_info**
  * Mondd el, mi az a P200 termék.
  * Tudsz adni infót a Vezeték nélküli egérről?

### Prompt-sablon a Gemini-2.0-flash modellhez

```text
System:
Elemezd a következő felhasználói mondatot, és add vissza kizárólag JSON formátumban:
  {
    "intent": "...",
    "entities": { ... }
  }
Ne írj semmi mást, csak a tiszta JSON-t.

User:
"{user_utterance}"

```

### 2.3. Planner komponens logikája

1. **Input→Output mapping**

   * Bemenet: szabad szöveg
   * Kimenet: JSON `{ intent, entities }`
2. **Promptolás implementálása**

   * `def parse_user_input(text):`

     * `response = call_gemini(prompt=text, system="Intent+Entity extraction")`
     * `return json.loads(response)`
3. **Hibakezelés**

   * Ha nincs intent vagy nincs entity → kérj kiegészítést a user-től

### 2.4. Alfeladat-lista (Task Palette) összeállítása

Az ügynök minden egyes kérdésre az alábbi alfeladatokat hajtja végre:

1. **Szándék felismerés** (`parse_user_input`)
2. **Entity kinyerés** (order\_id, dátum stb.)
3. **Tool Invocation**

   * Ha `intent == order_status` → `get_order_info({order_id: ...})`
   * Ha `intent == shipping_time` → ugyanaz a tool, más output formázással
4. **Memory update**

   * `memory["history"].append({ "user": text, "agent": intent+result })`
5. **Válasz formázása**

   * Emberi nyelvű sor, pl. „Az A1003 státusza: Feldolgozás alatt…”
   * JSON response → agent\_reply

### 2.5. Memóriakezelés tervezése

1. **Memory-struktúra** (`memory.json`)

   ```json
   {
     "history": [
       { "timestamp": "...", "user": "...", "intent": "...", "entities": {...}, "agent": "..." }
     ]
   }
   ```

2. **Memory API**

   * `load_memory()`, `save_memory(mem)` – már készen van a tools.py-ban
   * `def log_interaction(user, intent, entities, agent):`

     ```python
     mem = load_memory()
     mem["history"].append({ ... })
     save_memory(mem)
     ```

3. **Hány beszélgetési kör tárolása?**

   * Teljes history vs. csak legutóbbi N kör – egyszerűbben: mindet

### 2.6. Végrehajtási terv összefűzése

1. **parse\_user\_input** → intent+entities
2. **ha intent és order\_id van** → invoke get\_order\_info
3. **formázd a választ**, logold a memóriába
4. **response** kiküldése a felhasználónak

### 2.7. Tesztesetek és edge case-ek

* Hibás order\_id → „Nincs ilyen rendelés”
* Hiányzó entity (nincs order\_id) → „Kérem, add meg a rendelésazonosítót!”
* Több entity találat → „Melyik rendelésre gondolsz: A1003 vagy A1004?”

### 2.8. Dokumentáció és kódstruktúra

* `planner.py` → intent/entity parser
* `executor.py` → tool hívások, válasz generálás
* `memory.py` → memoria API wrappek
* `main.py` → CLI vagy HTTP endpoint, ami mindezeket összefűzi

---




### ✅ **3. lépés: Ügynök inicializálása (Memory Management)**

* Írj egy függvényt, ami betölti és frissíti a memória állapotát a `memory.json`-ből (`tools.py`-ban már kész).
* Ügyelj arra, hogy minden lépést logolj a memóriába (pl. beérkező kérdések, válaszok).

### ✅ **4. lépés: Alapvető Planner implementáció (Gemini API)**

* Implementáld a `planner` függvényt:

  * Hívd meg a gemini-2.0-flash modellt, add át a felhasználó kérdését.
  * Kérd meg a modellt, hogy határozza meg:

    * Milyen típusú kérdésről van szó?
    * Milyen rendelési azonosítót tartalmaz (ha van)?
* Példa válasz a modelltől:

```json
{
  "intent": "order_status",
  "order_id": "A1003"
}
```

### ✅ **5. lépés: Executor implementáció**

* Használd a már kész `get_order_info()` függvényt a `tools.py`-ból.
* Adj vissza választ, vagy hibaüzenetet, ha nincs ilyen rendelés.

**Executor kimeneti példája:**

```json
{
  "order_id": "A1003",
  "status": "Teljesítve",
  "shipping_date": "2025-05-01",
  "delivery_estimate": "2025-05-07"
}
```

### ✅ **6. lépés: Visszacsatolási hurok (Feedback Loop)**

* Ha a végrehajtás hibát jelez (pl. nincs ilyen rendelés), újra hívd a Planner-t, hogy értelmezze újra a kérdést vagy kérjen további tisztázást a felhasználótól.
* A ciklust addig folytasd, míg a kérdés kielégítően nincs megválaszolva.

### ✅ **7. lépés: CLI Chatbot Interface**

* Hozz létre egy egyszerű CLI-t, amin keresztül felhasználók beírhatják kérdéseiket.
* A chatbot iteratívan adjon választ és kérjen pontosítást, ha szükséges.

Példa futtatásra (`main.py` CLI-n keresztül):

```
Felhasználó: Hol tart az A1003-as rendelésem?
Chatbot: Az A1003 rendelés státusza: Teljesítve. 
Szállítás dátuma: 2025-05-01, várható érkezés: 2025-05-07.

Felhasználó: Mi a helyzet az A9999 rendelésemmel?
Chatbot: Nem találom az A9999 rendelést. Kérlek ellenőrizd a rendelés azonosítót és próbáld újra!
```

---

## További lehetséges lépések / kiterjesztések

Ha az alap chatbot elkészült és működik, ezeket a további lépéseket érdemes lehet megfontolni:

* **Finomhangolás és javítás:**

  * Bővítsd ki a chatbot értelmezési képességeit (többféle kérdéstípus).
  * Integráld hibakezelést és visszacsatolási mechanizmust részletesebben.

* **Bővebb memória használata:**

  * Tárold a felhasználó előző kérdéseit és válaszait hosszabb távon is, ne csak egy beszélgetésen belül.

* **Felhasználói interakció:**

  * Építs ki webes vagy grafikus interfészt a chatbot köré.

* **Elemzés és statisztikák:**

  * Rögzítsd az interakciókat elemzéshez (pl. gyakran ismételt kérdések, hibák gyakorisága).

---

Ezzel a részletes tervvel átláthatóvá válik a folyamat, és könnyedén elindulhatsz a kódolásban. Ha bármelyik lépésnél elakadsz, vagy további részletekre van szükséged, szívesen segítek további magyarázatokkal vagy példákkal!


requirements.txt tartalma:
torch
numpy
matplotlib
tiktoken
tqdm
jupyter
pandas
transformers 
accelerate 
bitsandbytes
pathlib
pytest
google-genai
re
json

tools.py tartalma:
import json
from pathlib import Path
from google import genai

# ——————————————————————————————————————————————
# OpenAI Gemini (Google GenAI) kliens inicializálása
# ——————————————————————————————————————————————
API_KEY = "AIzaSyAy3PX1bQX5i8N6ZivmYv5r7HYk3couFQA"
client = genai.Client(api_key=API_KEY)

def call_gemini_api(model: str, contents: str = None, prompt: str = None) -> str:
    payload = contents or prompt or ""
    """
    Meghívja a Google GenAI Gemini modellt.
    Paraméterek:
      - model: pl. "gemini-2.0-flash"
      - contents: a prompt, amire JSON-t fog kérni például intent/entity parsing-re
    Visszatér:
      a Gemini válaszának szöveges tartalma (általában JSON-formátum).
    """
    try:
        response = client.models.generate_content(
            model=model,
        contents=payload
        )
        return response.text
    except Exception as e:
        # Hibát JSON-ben visszaadjuk, hogy a parser kezelni tudja
        return json.dumps({"error": str(e)})

# ——————————————————————————————————————————————
# Order-tool: rendelés-adatok lekérése orders.json-ből
# ——————————————————————————————————————————————
def get_order_info(args: dict) -> dict:
    """
    Betölti az 'orders.json'-t és visszaadja a megadott order_id-hez tartozó
    rendelés-objektumot. Ha nincs találat, {"error": "..."}-t ad vissza.
    """
    try:
        with open("orders.json", "r", encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        return {"error": "orders.json fájl nem található."}

    for order in data.get("orders", []):
        if order.get("order_id") == args.get("order_id"):
            return order
    return {"error": f"Nincs ilyen rendelés: {args.get('order_id')}"}

# ——————————————————————————————————————————————
# Memória-tool: beszélgetési előzmények mentése/beolvasása
# ——————————————————————————————————————————————
def load_memory() -> dict:
    """
    Betölti a 'memory.json'-t. Ha nincs, üres history-val tér vissza.
    """
    try:
        with open("memory.json", "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return {"history": []}

def save_memory(mem: dict) -> None:
    """
    Elmenti a mem dict-et 'memory.json' néven, szép formázással.
    """
    with open("memory.json", "w", encoding="utf-8") as f:
        json.dump(mem, f, ensure_ascii=False, indent=2)


validator.py tartalma:
import re
import json
from pathlib import Path

# Konfiguráció betöltése
CONFIG_DIR = Path(__file__).parent / "config"
INTENTS = json.loads((CONFIG_DIR / "intents.json").read_text(encoding="utf-8"))
ENTITIES = json.loads((CONFIG_DIR / "entities.json").read_text(encoding="utf-8"))

class ValidationError(Exception):
    pass

def validate_intent(intent: str):
    if intent not in INTENTS:
        raise ValidationError(f"Ismeretlen intent: {intent}")

def validate_entities(intent: str, entities: dict):
    # Kötelező entitások ellenőrzése
    required = INTENTS[intent]["required_entities"]
    missing = [e for e in required if e not in entities or not entities[e]]
    if missing:
        raise ValidationError(f"Hiányzó entitás(ok): {', '.join(missing)}")
    # Formátum-ellenőrzés az entities.json pattern alapján
    for name, value in entities.items():
        spec = ENTITIES.get(name)
        if spec and "pattern" in spec:
            if not re.match(spec["pattern"], value):
                raise ValidationError(f"Érvénytelen formátumú entitás `{name}`: `{value}`")

def parse_and_validate(text: str) -> dict:
    from planner import parse_user_input
    res = parse_user_input(text)
    intent, entities = res["intent"], res["entities"]
    validate_intent(intent)
    validate_entities(intent, entities)
    return res


.pytest_cache\CACHEDIR.TAG tartalma:
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html


.pytest_cache\README.md tartalma:
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


.pytest_cache\v\cache\lastfailed tartalma:
{}

.pytest_cache\v\cache\nodeids tartalma:
[
  "tests/test_planner.py::test_parse_cancel_order",
  "tests/test_planner.py::test_parse_order_history",
  "tests/test_planner.py::test_parse_product_info",
  "tests/test_planner.py::test_parse_shipping_time",
  "tests/test_planner.py::test_parse_simple_intent",
  "tests/test_planner.py::test_plan_validation_error",
  "tests/test_tools.py::test_get_order_not_found",
  "tests/test_tools.py::test_get_order_ok",
  "tests/test_tools.py::test_memory_roundtrip",
  "tests/test_validator.py::test_validate_entities_missing",
  "tests/test_validator.py::test_validate_entities_ok",
  "tests/test_validator.py::test_validate_entities_pattern",
  "tests/test_validator.py::test_validate_intent_ok",
  "tests/test_validator.py::test_validate_intent_unknown"
]

.pytest_cache\v\cache\stepwise tartalma:
[]

config\entities.json tartalma:
{
    "order_id": {
        "type": "string",
        "pattern": "A[0-9]{4}(?:-as)?",
        "description": "Rendelés azonosító (pl. A1003 vagy A1003-as)"
    },
    "product_id": {
        "type": "string",
        "pattern": "^P[0-9]{3}$",
        "description": "Termékazonosító (pl. P200)"
    },
    "product_name": {
        "type": "string",
        "description": "Termék neve (pl. \"Vezeték nélküli egér\")"
    },
    "customer_name": {
        "type": "string",
        "description": "Vásárló neve (pl. \"Kovács Ádám\")"
    },
    "new_address": {
        "type": "string",
        "description": "Új szállítási cím"
    },
    "reason": {
        "type": "string",
        "description": "Visszatérítés oka"
    },
    "date": {
        "type": "string",
        "format": "date",
        "description": "Dátum (YYYY-MM-DD formátumban)"
    }
}

config\intents.json tartalma:
{
    "order_status": {
        "description": "Rendelés állapot lekérdezése",
        "required_entities": [
            "order_id"
        ],
        "sample_utterances": [
            "Hol tart az A1003-as rendelésem?",
            "Hol tart az A1003 as rendelésem?",
            "Mi a státusza az A1005-nek?",
            "Megnéznéd, hogy feldolgozás alatt van-e az A1002-es rendelésem?"
        ]
    },
    "shipping_time": {
        "description": "Szállítás várható idejének lekérdezése",
        "required_entities": [
            "order_id"
        ],
        "sample_utterances": [
            "Mikorra várható az A1005 szállítása?",
            "Mikor érkezik meg az A1004-es csomag?"
        ]
    },
    "cancel_order": {
        "description": "Rendelés törlése",
        "required_entities": [
            "order_id"
        ],
        "sample_utterances": [
            "Szeretném törölni az A1006-os rendelést.",
            "Hogyan mondhatom le az A1010-et?"
        ]
    },
    "order_history": {
        "description": "Az összes rendelés listázása",
        "required_entities": [],
        "sample_utterances": [
            "Mik a rendeléseim állapotai?",
            "Kérlek, mutasd a korábbi rendelések listáját!"
        ]
    },
    "greeting": {
        "description": "Üdvözlés, kezdeti köszönés",
        "required_entities": [],
        "sample_utterances": [
            "Szia!",
            "Helló, miben tudsz segíteni?"
        ]
    },
    "goodbye": {
        "description": "Búcsú, beszélgetés lezárása",
        "required_entities": [],
        "sample_utterances": [
            "Köszönöm, viszlát!",
            "Minden jót!"
        ]
    },
    "help": {
        "description": "Segítségkérés, elérhető parancsok ismertetése",
        "required_entities": [],
        "sample_utterances": [
            "Miben tudsz segíteni?",
            "Mit tudsz?"
        ]
    },
    "product_info": {
        "description": "Termékinformáció lekérdezése",
        "required_entities": [
            "product_id"
        ],
        "sample_utterances": [
            "Mondd el, mi az a P200 termék.",
            "Tudsz adni infót a Vezeték nélküli egérről?"
        ]
    }
}

tests\test_executor.py tartalma:
def test_invoke_order_status_valid(monkeypatch):
    from executor import invoke_order_status
    # monkeypatch nem kell, mert get_order_info tényleg olvassa az orders.json-t
    out = invoke_order_status("A1003")
    assert out["order_id"] == "A1003"
    assert "status" in out

def test_invoke_order_status_invalid():
    from executor import invoke_order_status
    out = invoke_order_status("XXXX")
    assert "error" in out

tests\test_planner.py tartalma:
import pytest
from planner import parse_user_input, plan

def test_parse_simple_intent(monkeypatch):
    fake = '{"intent":"order_status","entities":{"order_id":"A1003"}}'
    monkeypatch.setattr("planner.call_gemini_api", lambda **kw: fake)
    res = parse_user_input("Hol tart az A1003-as rendelésem?")
    assert res["intent"] == "order_status"
    assert res["entities"]["order_id"] == "A1003"

def test_parse_shipping_time(monkeypatch):
    fake = '{"intent":"shipping_time","entities":{"order_id":"A1005"}}'
    monkeypatch.setattr("planner.call_gemini_api", lambda **kw: fake)
    res = parse_user_input("Mikorra várható az A1005 szállítása?")
    assert res["intent"] == "shipping_time"
    assert res["entities"]["order_id"] == "A1005"

def test_parse_order_history(monkeypatch):
    fake = '{"intent":"order_history","entities":{}}'
    monkeypatch.setattr("planner.call_gemini_api", lambda **kw: fake)
    res = parse_user_input("Mik a rendeléseim állapotai?")
    assert res["intent"] == "order_history"
    assert res["entities"] == {}

def test_parse_cancel_order(monkeypatch):
    fake = '{"intent":"cancel_order","entities":{"order_id":"A1010"}}'
    monkeypatch.setattr("planner.call_gemini_api", lambda **kw: fake)
    res = parse_user_input("Törölném az A1010-es rendelést.")
    assert res["intent"] == "cancel_order"
    assert res["entities"]["order_id"] == "A1010"

def test_parse_product_info(monkeypatch):
    fake = '{"intent":"product_info","entities":{"product_id":"P200"}}'
    monkeypatch.setattr("planner.call_gemini_api", lambda **kw: fake)
    res = parse_user_input("Mondd el, mi az a P200 termék.")
    assert res["intent"] == "product_info"
    assert res["entities"]["product_id"] == "P200"

def test_plan_validation_error(monkeypatch):
    monkeypatch.setattr("planner.parse_user_input", lambda t: {"intent":"order_status","entities":{}})
    res = plan("Hol tart az A1003-as rendelésem?")
    assert "error" in res


tests\test_tools.py tartalma:
import pytest
from tools import get_order_info, load_memory, save_memory
import shutil
from pathlib import Path

def test_get_order_ok():
    info = get_order_info({"order_id": "A1003"})
    assert info["order_id"] == "A1003"
    assert "status" in info

def test_get_order_not_found():
    info = get_order_info({"order_id": "ZZZZ"})
    assert "error" in info

def test_memory_roundtrip(tmp_path):
    # Eredeti memory.json biztonsági mentése
    original = Path("memory.json")
    backup = tmp_path / "memory_orig.json"
    if original.exists():
        shutil.copy(original, backup)

    # Load–modify–save kör
    mem = load_memory()
    assert isinstance(mem, dict) and "history" in mem
    mem["history"].append("x")
    save_memory(mem)
    assert load_memory()["history"][-1] == "x"

    # Backup visszaállítása eredetire
    if backup.exists():
        shutil.copy(backup, original)


tests\test_validator.py tartalma:
import pytest
from validator import validate_intent, validate_entities, ValidationError

def test_validate_intent_ok():
    validate_intent("order_status")

def test_validate_intent_unknown():
    with pytest.raises(ValidationError):
        validate_intent("nonsuch_intent")

def test_validate_entities_ok():
    validate_entities("order_status", {"order_id": "A1003"})

def test_validate_entities_missing():
    with pytest.raises(ValidationError):
        validate_entities("order_status", {})

def test_validate_entities_pattern():
    with pytest.raises(ValidationError):
        validate_entities("order_status", {"order_id": "XYZ"})


